token<prio=1> uint8zero = "\x00" ;
token<prio=1> uint8one = "\x01" ;
token<prio=1> uint8start = "\x16" ;
token uint8any = "." ;
token<prio=1> uint16zero = "\x00\x00" ;
token uint16any = "..?" ;
token uint24any = "..?.?" ;
token<prio=1> uint16versaccept = "\0x03[\x01\x02\x03]" ;

tlsmsg = 
uint8start tlsversdata
/* { if (1) { 0; } } */
;

tlsversdata = 
uint16versaccept tlsdata
;

tlsdata = 
uint16any<cb=szbe> bytes<feed=sslhandshake>
;

sni = 
uint8zero uint16any<cb=szbe> bytes<cb=print>
| uint8any uint16any<cb=szbe> bytes
;

maybe_sniext2 = 
| sni maybe_sniext2
;

sniext2 = sni maybe_sniext2
;

sniext = uint16any<cb=szbe> bytes<reinit_feed=sniext2>
;

extensions = 
| extension extensions
;

extension = 
uint16zero uint16any<cb=szbe> bytes<reinit_feed=sniext>
| uint16any uint16any<cb=szbe> bytes
;

sslhandshakedata2 = 
bytes
uint8any<cb=szbe>
bytes
uint16any<cb=szbe>
bytes
uint8any<cb=szbe>
bytes
uint16any<cb=szbe>
bytes<reinit_feed=extensions>
;

sslhandshakedata = 
uint16versaccept action<cb=szset32> sslhandshakedata2 ;

sslhandshake = 
uint8one uint24any<cb=szbe> bytes<feed=sslhandshakedata>
;

directive entry = sslhandshake ;
directive entry = sslhandshakedata ;
directive entry = extensions ;
directive entry = sniext ;
directive main = tlsmsg ;
directive parsername = tls ;
